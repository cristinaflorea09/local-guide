import Foundation

/// Trip plan generated by AI Trip Designer.
/// Stored in Firestore under `tripPlans/{id}`.
struct TripPlan: Codable, Identifiable {
    let id: String
    let uid: String
    var country: String
    var city: String
    var startDateISO: String
    var endDateISO: String
    var interests: [String]
    var budgetPerDay: Double?
    var pace: String?
    var groupSize: Int?
    var languageCode: String

    /// The model output (JSON object). We keep it as a dictionary for flexibility.
    var plan: [String: AnyCodable]
    var createdAt: Date?
}

/// Minimal AnyCodable to decode JSON objects returned by the backend.
struct AnyCodable: Codable, Hashable, Equatable {
    let value: Any

    init(_ value: Any) { self.value = value }

    init(from decoder: Decoder) throws {
        let c = try decoder.singleValueContainer()
        if let v = try? c.decode(Bool.self) { value = v; return }
        if let v = try? c.decode(Int.self) { value = v; return }
        if let v = try? c.decode(Double.self) { value = v; return }
        if let v = try? c.decode(String.self) { value = v; return }
        if let v = try? c.decode([AnyCodable].self) { value = v; return }
        if let v = try? c.decode([String: AnyCodable].self) { value = v; return }
        value = NSNull()
    }

    func encode(to encoder: Encoder) throws {
        var c = encoder.singleValueContainer()
        switch value {
        case let v as Bool: try c.encode(v)
        case let v as Int: try c.encode(v)
        case let v as Double: try c.encode(v)
        case let v as String: try c.encode(v)
        case let v as [AnyCodable]: try c.encode(v)
        case let v as [String: AnyCodable]: try c.encode(v)
        default: try c.encodeNil()
        }
    }

    static func == (lhs: AnyCodable, rhs: AnyCodable) -> Bool {
        switch (lhs.value, rhs.value) {
        case (let l as Bool, let r as Bool): return l == r
        case (let l as Int, let r as Int): return l == r
        case (let l as Double, let r as Double): return l == r
        case (let l as String, let r as String): return l == r
        case (let l as [AnyCodable], let r as [AnyCodable]): return l == r
        case (let l as [String: AnyCodable], let r as [String: AnyCodable]): return l == r
        case (_ as NSNull, _ as NSNull): return true
        default: return false
        }
    }

    func hash(into hasher: inout Hasher) {
        switch value {
        case let v as Bool:
            hasher.combine(0)
            hasher.combine(v)
        case let v as Int:
            hasher.combine(1)
            hasher.combine(v)
        case let v as Double:
            hasher.combine(2)
            hasher.combine(v)
        case let v as String:
            hasher.combine(3)
            hasher.combine(v)
        case let v as [AnyCodable]:
            hasher.combine(4)
            hasher.combine(v)
        case let v as [String: AnyCodable]:
            hasher.combine(5)
            // Dictionaries are unordered; to ensure stable hashing, combine sorted by key
            for key in v.keys.sorted() {
                hasher.combine(key)
                if let val = v[key] { hasher.combine(val) }
            }
        case _ as NSNull:
            hasher.combine(6)
        default:
            // Fallback for unsupported types
            hasher.combine(7)
        }
    }
}
